<html><head><base href="." /><meta charset="UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin"><meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp"><title>Statement Atomizer & Text Diff</title><style>
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    max-width: 900px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f5f5f5;
    color: #2d3748;
}

.container {
    background: white;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

textarea {
    width: 100%;
    min-height: 150px;
    padding: 1rem;
    margin: 1rem 0;
    border: 2px solid #e2e8f0;
    border-radius: 4px;
    font-size: 1rem;
    resize: vertical;
}

.text-inputs {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
}

button {
    background: #4a5568;
    color: white;
    border: none;
    padding: 0.75rem 1.5rem;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    transition: background 0.3s ease;
}

button:hover {
    background: #2d3748;
}

.output {
    margin-top: 2rem;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 2rem;
}

.pre-container {
    background: #1a1a1a;
    padding: 1rem;
    border-radius: 4px;
}

pre {
    font-family: monospace;
    margin: 0;
    color: #d4d4d4;
    line-height: 1.5;
    white-space: pre-wrap;
}

.chunk {
    display: inline;
    position: relative;
    padding: 2px 4px;
    margin: 0 2px;
    border-radius: 3px;
}

.chunk.semantic .word{
    background-color: rgba(255, 165, 0, 0.1);
}

.chunk.semantic:hover::after {
    content: attr(data-match);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: #4a90e2;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 14px;
    white-space: pre-wrap;
    z-index: 1000;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    max-width: 300px;
}

.word {
    display: inline-block;
}

.word.common {
    background-color: rgba(0, 255, 0, 0.1);
    color: #80ff80;
}

.word.unique {
    background-color: rgba(255, 0, 0, 0.1);
    color: #ff8080;
}

.chunk.semantic .word.word.unique {
    background-color: rgba(255, 165, 0, 0.1);
    color: #ffa500;
}

.word.common:hover::after {
    content: 'Common word';
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: #2ecc71;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 14px;
    white-space: nowrap;
    z-index: 1000;
}

.chunk:not(.semantic) .word.unique:hover::after {
    content: 'Unique word';
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: #e74c3c;
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 14px;
    white-space: nowrap;
    z-index: 1000;
}

.stats {
    display: flex;
    gap: 2rem;
    margin: 2rem 0;
    padding: 1rem;
    background: #2d3748;
    border-radius: 4px;
    color: white;
}

.stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
}

.stat-value {
    font-size: 1.5rem;
    font-weight: bold;
}

.stat-label {
    font-size: 0.875rem;
    opacity: 0.8;
}

.controls {
    display: flex;
    gap: 20px;
    margin: 10px 0;
    align-items: center;
}

.threshold-control, .chunk-control {
    display: flex;
    align-items: center;
    gap: 10px;
}

.chunk-control select {
    padding: 5px;
    border-radius: 4px;
    border: 1px solid #ccc;
}

.toggle-buttons {
    display: flex;
    gap: 10px;
    margin: 10px 0;
}

.toggle-button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: opacity 0.3s;
}

.toggle-button.active {
    opacity: 1;
}

.toggle-button.inactive {
    opacity: 0.5;
}

#toggleCommon {
    background-color: #90EE90;
}

#toggleSemantic {
    background-color: #87CEEB;
}

#toggleUnique {
    background-color: #FFB6C1;
}

.text-column {
    animation: fadeIn 0.3s ease-in;
}

.text-column h3 {
    color: white;
    margin-bottom: 1rem;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}
</style></head><body>
<div class="container">
    <h1>Statement Atomizer & Text Diff</h1>
    <p>Enter two texts below to compare their words.</p>
    
    <div class="text-inputs">
        <div>
            <h3>Text 1</h3>
            <textarea id="inputText1" placeholder="Enter your first text here..."></textarea>
        </div>
        <div>
            <h3>Text 2</h3>
            <textarea id="inputText2" placeholder="Enter your second text here..."></textarea>
        </div>
    </div>
    
    <div class="controls">
        <button onclick="compareTexts()">Compare Texts</button>
        <button onclick="clearAll()">Clear</button>
        <div class="threshold-control">
            <label for="threshold">Similarity Threshold:</label>
            <input type="number" id="threshold" min="0" max="1" step="0.1" value="0.7">
        </div>
        <div class="chunk-control">
            <label for="chunkSize">Chunk Size (words):</label>
            <select id="chunkSize">
                <option value="1">Single words</option>
                <option value="2">2 words</option>
                <option value="3">3 words</option>
                <option value="4">4 words</option>
                <option value="5">5 words</option>
                <option selected value="sentence">Full sentences</option>
            </select>
        </div>
    </div>
    
    <div id="stats" class="stats" style="display: none;"></div>
    <div class="toggle-buttons">
        <button id="toggleCommon" class="toggle-button active">Common Words</button>
        <button id="toggleSemantic" class="toggle-button active">Semantic Matches</button>
        <button id="toggleUnique" class="toggle-button active">Unique Words</button>
    </div>
    <div class="output" id="output"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3"></script>

<script>
let useModel = null;

async function loadModel() {
    try {
        if (!useModel) {
            const statsDiv = document.getElementById('stats');
            statsDiv.style.display = 'flex';
            statsDiv.innerHTML = `
                <div class="stat-item">
                    <div class="stat-label">Loading model...</div>
                </div>`;
            
            useModel = await use.load();
            statsDiv.style.display = 'none';
        }
        return useModel;
    } catch (error) {
        console.error('Model loading error:', error);
        const statsDiv = document.getElementById('stats');
        statsDiv.style.display = 'flex';
        statsDiv.innerHTML = `
            <div class="stat-item">
                <div class="stat-label" style="color: #ff8080;">
                    Error loading model. Please check your connection and try again.
                    Details: ${error.message}
                </div>
            </div>`;
        throw error;
    }
}

async function getEmbeddings(texts) {
    try {
        const model = await loadModel();
        const embeddings = await model.embed(texts);
        return embeddings.arraySync();
    } catch (error) {
        console.error('Error getting embeddings:', error);
        throw error;
    }
}

function cosineSimilarity(vecA, vecB) {
    const dotProduct = vecA.reduce((acc, val, i) => acc + val * vecB[i], 0);
    const magnitudeA = Math.sqrt(vecA.reduce((acc, val) => acc + val * val, 0));
    const magnitudeB = Math.sqrt(vecB.reduce((acc, val) => acc + val * val, 0));
    return dotProduct / (magnitudeA * magnitudeB);
}

function getChunks(text, words, chunkSize) {
    if (chunkSize === 'sentence') {
        // Join words back into text and split into lines
        const lines = text.split('\n');
        const sentences = [];
        
        lines.forEach(line => {
            if (line.trim()) {
                // Split line by sentence endings while preserving the endings
                const lineSentences = line.match(/(?:^|(?<=[.,?!]))\s*[^.,?!\d][^.,!?]*(?:\.\s+|\?\s+|!\s+|,\s+|$)/g);
                if (lineSentences) {
                    sentences.push(...lineSentences);
                } else {
                    // If no sentence endings found, treat the line as a sentence
                    sentences.push(line);
                }
            }
        });
        
        // If no sentences were found, use the whole text
        if (sentences.length === 0) {
            sentences.push(text);
        }
        
        return sentences.map(s => ({
            text: s.trim(),
            words: s.trim().split(/\s+/).filter(w => w.length > 0)
        }));
    }
    
    const size = parseInt(chunkSize);
    if (size <= 1) return words.map(w => ({
        text: w,
        words: [w]
    }));
    
    const chunks = [];
    for (let i = 0; i < words.length; i += size) {
        const chunkWords = words.slice(i, i + size);
        chunks.push({
            text: chunkWords.join(' '),
            words: chunkWords
        });
    }
    return chunks;
}

function mapChunkMatchesToWords(chunk, matches) {
    const wordMatches = new Map();
    
    if (matches.has(chunk.text)) {
        const chunkMatch = matches.get(chunk.text);
        const matchWords = chunkMatch.match.split(/\s+/);
        
        chunk.words.forEach((word, idx) => {
            wordMatches.set(word, {
                match: matchWords[idx] || matchWords[matchWords.length - 1],
                similarity: chunkMatch.similarity,
                chunkMatch: chunkMatch.match
            });
        });
    }
    
    return wordMatches;
}

async function findSemanticMatches(text1, text2, words1, words2, threshold) {
    try {
        const model = await loadModel();
        const chunkSize = document.getElementById('chunkSize').value;
        
        // Get chunks while preserving original words
        const chunks1 = getChunks(text1, words1, chunkSize);
        const chunks2 = getChunks(text2, words2, chunkSize);
        
        // Get embeddings for the full chunk texts
        const embeddings1 = await model.embed(chunks1.map(c => c.text));
        const embeddings2 = await model.embed(chunks2.map(c => c.text));
        
        const embeddings1Array = embeddings1.arraySync();
        const embeddings2Array = embeddings2.arraySync();
        
        const chunkMatches = new Map();
        
        // Find matches between chunks
        for (let i = 0; i < chunks1.length; i++) {
            const chunk1 = chunks1[i];
            let bestMatch = null;
            let bestSimilarity = 0;
            
            for (let j = 0; j < chunks2.length; j++) {
                const chunk2 = chunks2[j];
                const similarity = cosineSimilarity(embeddings1Array[i], embeddings2Array[j]);
                
                if (similarity > threshold && similarity > bestSimilarity) {
                    bestMatch = chunk2;
                    bestSimilarity = similarity;
                }
            }
            
            if (bestMatch) {
                chunkMatches.set(chunk1.text, {
                    match: bestMatch.text,
                    similarity: bestSimilarity
                });
            }
        }
        
        return chunkMatches;
    } catch (error) {
        console.error('Error in semantic matching:', error);
        throw error;
    }
}

async function compareTexts() {
    try {
        const text1 = document.getElementById('inputText1').value;
        const text2 = document.getElementById('inputText2').value;
        
        if (!text1 || !text2) {
            const statsDiv = document.getElementById('stats');
            statsDiv.style.display = 'flex';
            statsDiv.innerHTML = `
                <div class="stat-item">
                    <div class="stat-label" style="color: #ff8080;">Please enter text in both fields.</div>
                </div>`;
            return;
        }

        const statsDiv = document.getElementById('stats');
        statsDiv.style.display = 'flex';
        statsDiv.innerHTML = `
            <div class="stat-item">
                <div class="stat-label">Processing texts...</div>
            </div>`;
        
        const lines1 = text1.split('\n');
        const lines2 = text2.split('\n');
        
        const words1 = text1.split(/\s+/).filter(w => w.length);
        const words2 = text2.split(/\s+/).filter(w => w.length);
        
        const normalizedWords1 = words1.map(w => w.toLowerCase().replace(/[.,!?;:'"()]/g, ''));
        const normalizedWords2 = words2.map(w => w.toLowerCase().replace(/[.,!?;:'"()]/g, ''));
        
        const wordSet2 = new Set(normalizedWords2);
        const wordSet1 = new Set(normalizedWords1);
        
        const semanticMatches = await findSemanticMatches(
            text1,
            text2,
            words1,
            words2,
            parseFloat(document.getElementById('threshold').value)
        );
        
        const output = document.getElementById('output');
        output.innerHTML = '';

        const text1Div = document.createElement('div');
        text1Div.className = 'text-column';
        const text2Div = document.createElement('div');
        text2Div.className = 'text-column';

        const pre1Container = document.createElement('div');
        pre1Container.className = 'pre-container';
        const pre2Container = document.createElement('div');
        pre2Container.className = 'pre-container';

        const pre1 = document.createElement('pre');
        const pre2 = document.createElement('pre');

        const chunkSize = document.getElementById('chunkSize').value;

        lines1.forEach((line, lineIndex) => {
            if (line.trim()) {
                const lineChunks = getChunks(line, line.split(/\s+/).filter(w => w.length), chunkSize);
                lineChunks.forEach((chunk, chunkIndex) => {
                    const chunkSpan = document.createElement('span');
                    chunkSpan.className = 'chunk';
                    
                    // Handle words within the chunk
                    chunk.words.forEach((word, i) => {
                        const wordSpan = document.createElement('span');
                        const normalizedWord = word.toLowerCase().replace(/[.,!?;:'"()]/g, '');
                        
                        if (wordSet2.has(normalizedWord)) {
                            wordSpan.className = 'word common';
                        } else {
                            wordSpan.className = 'word unique';
                        }
                        
                        wordSpan.textContent = word + (i < chunk.words.length - 1 ? ' ' : '');
                        chunkSpan.appendChild(wordSpan);
                    });
                    
                    if (semanticMatches.has(chunk.text)) {
                        chunkSpan.className += ' semantic';
                        const match = semanticMatches.get(chunk.text);
                        chunkSpan.setAttribute('data-match', 
                            `Semantic match. 
                            This: "${chunk.text}"
                            Match: "${match.match}"
                            Similarity: ${(match.similarity * 100).toFixed(1)}%`);
                    }
                    
                    pre1.appendChild(chunkSpan);
                    if (chunkIndex < lineChunks.length - 1) {
                        pre1.appendChild(document.createTextNode(' '));
                    }
                });
            }
            if (lineIndex < lines1.length - 1) {
                pre1.appendChild(document.createTextNode('\n'));
            }
        });

        lines2.forEach((line, lineIndex) => {
            if (line.trim()) {
                const lineChunks = getChunks(line, line.split(/\s+/).filter(w => w.length), chunkSize);
                lineChunks.forEach((chunk, chunkIndex) => {
                    const chunkSpan = document.createElement('span');
                    chunkSpan.className = 'chunk';
                    
                    // Handle words within the chunk
                    chunk.words.forEach((word, i) => {
                        const wordSpan = document.createElement('span');
                        const normalizedWord = word.toLowerCase().replace(/[.,!?;:'"()]/g, '');
                        
                        if (wordSet1.has(normalizedWord)) {
                            wordSpan.className = 'word common';
                        } else {
                            wordSpan.className = 'word unique';
                        }
                        
                        wordSpan.textContent = word + (i < chunk.words.length - 1 ? ' ' : '');
                        chunkSpan.appendChild(wordSpan);
                    });
                    
                    if (Array.from(semanticMatches.values()).some(match => match.match === chunk.text)) {
                        chunkSpan.className += ' semantic';
                        const originalChunk = Array.from(semanticMatches.entries()).find(([_, match]) => match.match === chunk.text)[0];
                        const similarity = semanticMatches.get(originalChunk).similarity;
                        chunkSpan.setAttribute('data-match', 
                            `Semantic match 
                            This: "${chunk.text}"
                            Matches to:"${originalChunk}"
                            Similarity: ${(similarity * 100).toFixed(1)}%`);
                    }
                    
                    pre2.appendChild(chunkSpan);
                    if (chunkIndex < lineChunks.length - 1) {
                        pre2.appendChild(document.createTextNode(' '));
                    }
                });
            }
            if (lineIndex < lines2.length - 1) {
                pre2.appendChild(document.createTextNode('\n'));
            }
        });

        text1Div.innerHTML = '<h3>Text 1</h3>';
        text2Div.innerHTML = '<h3>Text 2</h3>';

        pre1Container.appendChild(pre1);
        pre2Container.appendChild(pre2);

        text1Div.appendChild(pre1Container);
        text2Div.appendChild(pre2Container);

        output.appendChild(text1Div);
        output.appendChild(text2Div);

        // After rendering both texts, calculate stats using DOM
        const exactMatches = document.querySelectorAll('.text-column:nth-of-type(1) .word.common').length;
        const semanticWords = document.querySelectorAll('.text-column:nth-of-type(1) .chunk.semantic .word:not(.common)').length;
        const uniqueWords1 = document.querySelectorAll('.text-column:nth-of-type(1) .chunk:not(.semantic) .word.unique').length;
        const uniqueWords2 = document.querySelectorAll('.text-column:nth-of-type(2) .chunk:not(.semantic) .word.unique').length;
        
        
        statsDiv.innerHTML = `
            <div class="stat-item">
                <div class="stat-value">${exactMatches}</div>
                <div class="stat-label">Exact Matches</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">${semanticWords}</div>
                <div class="stat-label">Semantic matches</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">${uniqueWords1}</div>
                <div class="stat-label">Unique words in Text 1</div>
            </div>
            <div class="stat-item">
                <div class="stat-value">${uniqueWords2}</div>
                <div class="stat-label">Unique words in Text 2</div>
            </div>
        `;
    } catch (error) {
        console.error('Error comparing texts:', error);
        const statsDiv = document.getElementById('stats');
        statsDiv.style.display = 'flex';
        statsDiv.innerHTML = `
            <div class="stat-item">
                <div class="stat-label" style="color: #ff8080;">Error processing texts: ${error.message}</div>
            </div>`;
    }
}

function clearAll() {
    document.getElementById('inputText1').value = '';
    document.getElementById('inputText2').value = '';
    document.getElementById('output').innerHTML = '';
    document.getElementById('stats').style.display = 'none';
}

window.addEventListener('load', async () => {
    try {
        await loadModel();
        
        // Add toggle button functionality
        const toggleButtons = {
            common: document.getElementById('toggleCommon'),
            semantic: document.getElementById('toggleSemantic'),
            unique: document.getElementById('toggleUnique')
        };
        
        const toggleStates = {
            common: true,
            semantic: true,
            unique: true
        };
        
        function updateWordVisibility() {
            // Common words
            const commonWords = document.querySelectorAll('.common');
            commonWords.forEach(word => {
                word.style.display = toggleStates.common ? '' : 'none';
            });
            
            // Semantic matches
            const semanticWords = document.querySelectorAll('.semantic');
            semanticWords.forEach(word => {
                word.style.display = toggleStates.semantic ? '' : 'none';
            });
            
            // Unique words
            const uniqueWords = document.querySelectorAll('.unique');
            uniqueWords.forEach(word => {
                word.style.display = toggleStates.unique ? '' : 'none';
            });
        }
        
        // Add click handlers for toggle buttons
        Object.entries(toggleButtons).forEach(([type, button]) => {
            button.addEventListener('click', () => {
                toggleStates[type] = !toggleStates[type];
                button.classList.toggle('active', toggleStates[type]);
                button.classList.toggle('inactive', !toggleStates[type]);
                updateWordVisibility();
            });
        });
        
    } catch (error) {
        console.error('Error loading model:', error);
    }
});
</script></body></html>